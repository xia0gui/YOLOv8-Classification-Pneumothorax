# -*- coding: utf-8 -*-
"""3_Training.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UTrv0eW0VkmnoByUCzU3MaSNymgWX3ex

**Import Library**
"""

# -*- coding: utf-8 -*-
# Google Colab Setup and Library Imports
from google.colab import drive
import os
import glob
import numpy as np
from PIL import Image
import cv2
import keras
import matplotlib.pyplot as plt
import pandas as pd

# Mount Google Drive
drive.mount('/content/drive')

"""# **Training**

## **Install YOLOv8**
"""

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/ultralytics/ultralytics.git

# %cd ultralytics

!pip install ultralytics

import ultralytics
ultralytics.checks()

"""## **Train YOLOv8**"""

import os
import shutil
from ultralytics import YOLO

# Paths
data_root = '/content/drive/MyDrive/kaggle_dataset/kfold_training_data'
output_folder = '/content/drive/MyDrive/kaggle_dataset/kfold_training_outputs1'
os.makedirs(output_folder, exist_ok=True)

# List of fold names
folds = [f'fold_{i}' for i in range(1, 6)]

# List to store paths of best models from each fold
best_model_paths = []

# Function to prepare data by combining selected folds for training and one fold for validation
def prepare_train_val_folders(train_folds, val_fold, temp_folder):
    # Clean up previous data
    if os.path.exists(temp_folder):
        shutil.rmtree(temp_folder)
    os.makedirs(temp_folder, exist_ok=True)

    train_folder = os.path.join(temp_folder, 'train')
    val_folder = os.path.join(temp_folder, 'val')

    # Create class folders for train and val
    for class_name in ['no_pneumothorax', 'pneumothorax']:
        os.makedirs(os.path.join(train_folder, class_name), exist_ok=True)
        os.makedirs(os.path.join(val_folder, class_name), exist_ok=True)

    # Copy validation data
    val_path = os.path.join(data_root, val_fold)
    for class_name in ['no_pneumothorax', 'pneumothorax']:
        val_class_path = os.path.join(val_path, class_name)
        for img_name in os.listdir(val_class_path):
            shutil.copy(os.path.join(val_class_path, img_name), os.path.join(val_folder, class_name, img_name))

    # Copy training data from the selected train folds
    for fold in train_folds:
        train_path = os.path.join(data_root, fold)
        for class_name in ['no_pneumothorax', 'pneumothorax']:
            train_class_path = os.path.join(train_path, class_name)
            for img_name in os.listdir(train_class_path):
                shutil.copy(os.path.join(train_class_path, img_name), os.path.join(train_folder, class_name, img_name))

# Training loop for each fold
for i in range(5):
    print(f'\n--- Training on Folds {folds[:i] + folds[i+1:]} and Validating on {folds[i]} ---')

    temp_data_folder = '/content/temp_fold_data'
    train_folds = folds[:i] + folds[i+1:]  # All folds except the current one
    val_fold = folds[i]                    # The current fold for validation

    # Prepare the combined training and validation data
    prepare_train_val_folders(train_folds, val_fold, temp_data_folder)

    # Initialize the YOLOv8 model (classification)
    model = YOLO('yolov8m-cls.pt')

    # Define output folder for the current fold
    fold_output_folder = os.path.join(output_folder, val_fold)

    # Train the model
    model.train(
        data=temp_data_folder,
        epochs=50,
        batch=16,
        imgsz=640,
        project=fold_output_folder,
        name=f'class_{val_fold}',
        verbose=True,
        optimizer='Adam',       #Use Adam ptimizer
        weight_decay=1e-4,      #L2 Regularization applied via weight decay
        lr0=0.005
    )

    # Store the path of the best model for this fold
    best_model_path = os.path.join(fold_output_folder, f'class_{val_fold}', 'weights', 'best.pt')
    best_model_paths.append(best_model_path)

    # Clean up temporary data folder
    shutil.rmtree(temp_data_folder)

print("\nK-Fold Cross-Validation Completed!")

"""# **Evaluation Metrics**"""

import pandas as pd
import matplotlib.pyplot as plt

# Paths to the results.csv files for each fold
results_csv_paths = [
    '/content/drive/MyDrive/kaggle_dataset/kfold_training_outputs1/fold_1/class_fold_1/results.csv',
    '/content/drive/MyDrive/kaggle_dataset/kfold_training_outputs1/fold_2/class_fold_2/results.csv',
    '/content/drive/MyDrive/kaggle_dataset/kfold_training_outputs1/fold_3/class_fold_3/results.csv',
    '/content/drive/MyDrive/kaggle_dataset/kfold_training_outputs1/fold_4/class_fold_4/results.csv',
    '/content/drive/MyDrive/kaggle_dataset/kfold_training_outputs1/fold_5/class_fold_5/results.csv'
]

# Read and combine the results.csv files for each fold
dataframes = [pd.read_csv(csv_path) for csv_path in results_csv_paths]
combined_metrics = pd.concat(dataframes, ignore_index=True)

# Group by epoch and compute the mean for train loss and validation loss
mean_metrics = combined_metrics.groupby('epoch')[['train/loss', 'val/loss']].mean()

# Plot the train and validation loss
plt.figure(figsize=(10, 6))
plt.plot(mean_metrics.index, mean_metrics['train/loss'], marker='o', label='Train Loss')
plt.plot(mean_metrics.index, mean_metrics['val/loss'], marker='o', label='Validation Loss')

# Graph details
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.title('Train and Validation Loss vs. Epochs')
plt.legend()
plt.grid(True)

# Show the plot
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Paths to the results.csv files for each fold
results_csv_paths = [
    '/content/drive/MyDrive/kaggle_dataset/kfold_training_outputs1/fold_1/class_fold_1/results.csv',
    '/content/drive/MyDrive/kaggle_dataset/kfold_training_outputs1/fold_2/class_fold_2/results.csv',
    '/content/drive/MyDrive/kaggle_dataset/kfold_training_outputs1/fold_3/class_fold_3/results.csv',
    '/content/drive/MyDrive/kaggle_dataset/kfold_training_outputs1/fold_4/class_fold_4/results.csv',
    '/content/drive/MyDrive/kaggle_dataset/kfold_training_outputs1/fold_5/class_fold_5/results.csv'
]

# Read and combine the results.csv files for each fold
dataframes = [pd.read_csv(csv_path) for csv_path in results_csv_paths]
combined_metrics = pd.concat(dataframes, ignore_index=True)

# Group by epoch and compute the mean for accuracy
mean_metrics = combined_metrics.groupby('epoch')[['metrics/accuracy_top1']].mean()

# Find the epoch and value of the highest accuracy
max_epoch = mean_metrics['metrics/accuracy_top1'].idxmax()
max_accuracy = mean_metrics['metrics/accuracy_top1'].max()

# Plot the Top-1 Accuracy vs. Epochs
plt.figure(figsize=(10, 6))
plt.plot(mean_metrics.index, mean_metrics['metrics/accuracy_top1'], marker='o', label='Accuracy Top-1')

# Highlight the highest accuracy point
plt.scatter(max_epoch, max_accuracy, color='red', zorder=3)
plt.text(max_epoch, max_accuracy, f'Max: {max_accuracy:.4f}', fontsize=10, color='red', ha='right', va='bottom')

# Graph details
plt.xlabel('Epochs')
plt.ylabel('Accuracy (Top-1)')
plt.title('Top-1 Accuracy vs. Epochs')
plt.legend()
plt.grid(True)

# Show the plot
plt.show()